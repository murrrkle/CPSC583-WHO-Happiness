<!DOCTYPE html>
<html lang="en">
<style>
    #path .active{
        fill: orange;
    }
</style>
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://unpkg.com/flubber@0.3.0"></script>
</head>
<body>
    <div id="mapcontainer" ></div>
    <div id="tooltipdev"></div>
    <script>
        //Adapted from:
        //http://datawanderings.com/2018/10/28/making-a-map-in-d3-js-v-5/
        //Map data retrieved from:
        //https://ec.europa.eu/eurostat/web/gisco/geodata/reference-data/administrative-units-statistical-units/countries

        //Grid Layout and parts of this code is also adapted from
        //https://observablehq.com/@karimdouieb/world-tile-grid-map


        const zoom = d3.zoom()
            .scaleExtent([1, 8])
            .on("zoom", zoomed);

        var block = false;
        var w = 1800;
        var h = 800;
        var margintop = 60;
        var marginside = 200;
        var centered;
        var viewbox = d3.select("#mapcontainer")
            .append("svg")
            .attr("preserveAspectRatio", "xMinYMin meet")
            .attr("viewBox", "0 0 " + w + " " + h)
            .style("background", "#c9e8fd")
        //   .classed("svg-content", true);

        var svg = viewbox.append("g");

        viewbox.call(zoom);

        //The following functions come for zoom implementation
        //https://observablehq.com/@d3/zoom-to-bounding-box
        function reset() {
            viewbox.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity,
                d3.zoomTransform(viewbox.node()).invert([w / 2, h / 2])
            );
        }

        function clicked(d) {
            const [[x0, y0], [x1, y1]] = path.bounds(d);
            d3.event.stopPropagation();
            viewbox.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity
                    .translate(w / 2, h / 2)
                    .scale(Math.min(8, 0.9 / Math.max((x1 - x0) / w, (y1 - y0) / h)))
                    .translate(-(x0 + x1) / 2, -(y0 + y1) / 2),
                d3.mouse(viewbox.node())
            );
        }

        function zoomed() {
            const {transform} = d3.event;
            svg.attr("transform", transform);
            svg.attr("stroke-width", 1 / transform.k);
        }

        //end of copied code

        //Modifed from previous code block
        function clickedbox(x0, y0, x1, y1) {
            d3.event.stopPropagation();
            viewbox.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity
                    .translate(w / 2, h / 2)
                    .scale(Math.min(8, 0.9 / Math.max((x1 - x0) / w, (y1 - y0) / h)))
                    .translate(-(x0 + x1) / 2, -(y0 + y1) / 2),
                d3.mouse(viewbox.node())
            );
        }

        var projection = d3.geoMercator()
            .translate([w/2, h/2])
            .scale(175)
            .center([0,40]);

        var path = d3.geoPath().projection(projection);

        var worldmap = d3.json("lowpolymap.geojson");

        var data = d3.json("datafixed.json");

        var grid = d3.json("mygrid.json");

        var spacing = Math.min(h/27, w/31);
        var size = spacing/2;
        var opp = Math.sin(Math.PI/6)*size;
        var adj = Math.cos(Math.PI/6)*size;

        var arr = [];

        for(let i =0; i<=31; i++){
            arr.push(i)
        }
        var xscale = d3.scaleBand(arr, [0+50 , w-50])
//            .padding(.1);


        var arr2 = [];

        for(let i =0; i<30; i++){
            arr2.push(i)
        }
        var yscale = d3.scaleBand()
            .domain(arr2)
            .range([0+50 , h-50]);

        console.log(yscale.bandwidth())
        var colorscale = d3.scaleSequential([0,8], d3.interpolateViridis)
            .nice();




        svg.append("clipPath")
            .attr("id", "clipCircle")
            .append("circle")
            .attr("r", function(d){
                return Math.min(xscale.bandwidth(), yscale.bandwidth())
            });

        //This code for building tooltips as well some other related code later on is adapted from:
        //https://www.d3-graph-gallery.com/graph/interactivity_tooltip.html
        var tooltip = d3.select("#mapcontainer")
            .append("div")
            .style("opacity", 0)
            .attr("class", "tooltip")
            .style("position", "absolute")
            .style("background-color", "white")
            .style("z-index", "10")
            .style("border", "solid")
            .style("stroke", 2)
            .style("stroke-color", "black")
            .style("border-width", "2px")
            .style("border-radius", "5px")
            .style("padding", "5px")



            Promise.all([worldmap, grid, data]).then(function (values) {


                function switchmode(option) {
                    svg.selectAll("path")
                        .transition()
                        .duration(3000)
                        .attrTween('d', d => {
                            let country = d.properties.ISO3_CODE;
                            let gridcountry = values[1].find(d => d.code === country);

                            var name = d.properties.NAME_ENGL;
                            let retname = values[2].find(d => d.Country === name);
                            let tracked = true;
                            if(retname == null){
                                tracked = false;
                            }

                            let x = gridcountry.x + 5;
                            let y = gridcountry.y;
                            let polyarr = d.geometry.coordinates;
                            var filteredPolygons = d.geometry.coordinates.map(coordinates => path({
                                type: 'Polygon',
                                coordinates: coordinates
                            }));
                            let type = d.geometry.type;
                            let shapefrom = [];
                            let shapeto = [];
                            if (type == "MultiPolygon") {


                                for (let el in polyarr) {
                                    shapefrom.push(filteredPolygons[el]);

                                    let j1;
                                    if(y % 2 == 1){
                                        j1 = x*2+1;
                                    }
                                    else{
                                        j1 = x*2;
                                    }
                                    let mid = [j1*spacing/2 +marginside, y*spacing +margintop];
                                    let top = {
                                        "x": mid[0],
                                        "y": mid[1]-size
                                    }
                                    let topleft = {
                                        "x": mid[0] + adj,
                                        "y": mid[1] - opp
                                    }
                                    let bottomleft = {
                                        "x": mid[0] + adj,
                                        "y": mid[1] + opp
                                    }
                                    let bottom = {
                                        "x": mid[0],
                                        "y": mid[1] + size
                                    }
                                    let bottomright = {
                                        "x": mid[0] - adj,
                                        "y": mid[1] + opp
                                    }
                                    let topright = {
                                        "x": mid[0] - adj,
                                        "y": mid[1] - opp
                                    }
                                    hex = d3.path();
                                    hex.moveTo(top.x, top.y);
                                    hex.lineTo(topleft.x, topleft.y);
                                    hex.lineTo(bottomleft.x, bottomleft.y);
                                    hex.lineTo(bottom.x, bottom.y);
                                    hex.lineTo(bottomright.x, bottomright.y);
                                    hex.lineTo(topright.x, topleft.y);
                                    hex.closePath();
                                    let sq = hex.toString();

                                    shape = d3.path();
                                    shape.moveTo(0,0);
                                    shape.lineTo(0,1);
                                    shape.lineTo(1,1);
                                    shape.closePath();
                                    shape = shape.toString();

                                    if(tracked){
                                        shapeto.push(sq)
                                    }
                                    else{
                                        shapeto.push(shape)
                                    }

                                }

                                shape = d3.path();
                                shape.moveTo(0,0);
                                shape.closePath();
                                if (option) {
                                    return flubber.interpolateAll(shapefrom, shapeto, {single: true})
                                } else {
                                    return flubber.interpolateAll(shapeto, shapefrom, {single: true})
                                }




                            } else {
                                let j1;
                                if(y % 2 == 1){
                                    j1 = x*2+1;
                                }
                                else{
                                    j1 = x*2;
                                }
                                let mid = [j1*spacing/2+marginside, y*spacing+margintop];
                                let top = {
                                    "x": mid[0],
                                    "y": mid[1]-size
                                }
                                let topleft = {
                                    "x": mid[0] + adj,
                                    "y": mid[1] - opp
                                }
                                let bottomleft = {
                                    "x": mid[0] + adj,
                                    "y": mid[1] + opp
                                }
                                let bottom = {
                                    "x": mid[0],
                                    "y": mid[1] + size
                                }
                                let bottomright = {
                                    "x": mid[0] - adj,
                                    "y": mid[1] + opp
                                }
                                let topright = {
                                    "x": mid[0] - adj,
                                    "y": mid[1] - opp
                                }
                                hex = d3.path();
                                hex.moveTo(top.x, top.y);
                                hex.lineTo(topleft.x, topleft.y);
                                hex.lineTo(bottomleft.x, bottomleft.y);
                                hex.lineTo(bottom.x, bottom.y);
                                hex.lineTo(bottomright.x, bottomright.y);
                                hex.lineTo(topright.x, topleft.y);
                                hex.closePath();


                                shape = d3.path();
                                shape.moveTo(0,0);
                                shape.lineTo(0,1);
                                shape.lineTo(1,1);
                                shape.closePath();

                                let square;
                                if(tracked){
                                    square = hex.toString();
                                }
                                else{
                                    square = shape.toString();
                                }

                                if (option) {
                                    return flubber.interpolate(path(d), square, {single: true})
                                } else {
                                    return flubber.interpolate(square, path(d), {single: true})
                                }

                            }

                        });

                }

                function onclick (d) {

                    var country = d.properties.ISO3_CODE;

                    var gridcountry  = values[1].find(d => d.code === country);


                    if (d && centered !== d) {
                        let x = gridcountry.x+5;
                        let y = gridcountry.y;
                        let j1;
                        if(y % 2 == 1){
                            j1 = x*2+1;
                        }
                        else{
                            j1 = x*2;
                        }
                        let mid = [j1*spacing/2 +marginside, y*spacing +margintop];
                        clickedbox(mid[0]-opp, mid[1]-size, mid[0]+opp, mid[1]+size);
                        if(!block){
                            switchmode(true);
                            block = true;
                        }
                        centered = d;

                    } else {
                        reset()
                        if(block){
                            switchmode(false);
                            block = false;
                        }

                        centered = null;

                    }

                    svg.selectAll("path")
                        .classed("active", centered && function(d) { return d === centered; });

                }

                let plot = svg.selectAll("g")
                    .data(values[0].features)
                    .enter()
                    .append("g");

                plot.append("path")
                    .attr("d", path)
                    .attr("fill",  function (d) {
                        let name = d.properties.NAME_ENGL;
                        let retname = values[2].find(d => d.Country === name);
                        if(retname != null){
                            return colorscale(retname.Happiness_score)
                        }
                        return "red";
                    })
                    .attr("stroke", "black")
                    .style('opacity', 0.8)
                    .style('stroke-width',0)

                    .on("mousemove", function (d){
                        var name = d.properties.NAME_ENGL;
                        tooltip.style("opacity", 1)
                            .html(function(d){
                                let retname = values[2].find(d => d.Country === name);
                                let happy = "not tracked";
                                if(retname != null){
                                    happy = retname.Happiness_score
                                }
                                return name + "<br>happiness score: " + happy;
                            })

                            .style('left', (d3.event.pageX + 10) + 'px')
                            .style('top', (d3.event.pageY ) + 'px')
                            .style('display', 'inline-block')
                    })
                    .on('mouseover',function(d){
                        d3.select(this)
                            .style('opacity', 1)
                            .style('stroke-width', 1);

                        tooltip
                            .style("opacity", 1)
                        d3.select(this)
                            .style("opacity", 1)


                    })
                    .on('mouseout', function(d){
                        d3.select(this)
                            .style('opacity', 0.8)
                            .style('stroke-width',0);
                        tooltip
                            .style("opacity", 0)
                    })
                    .on('click', function (d) {

                        svg.selectAll("path")
                            .attr("stroke", "black")
                            .style("stroke-width", 0)

                        d3.select(this)
                            .attr("stroke", "blue")
                            .style('stroke-width', 1)
                            .classed("Active", !d3.select(this).classed("Active"));

                        let name = d.properties.NAME_ENGL;
                        let retname = values[2].find(d => d.Country === name);
                        if(retname != null){
                            onclick(d);
                        }


                    });


                let group =viewbox.append("g")
                    .on('click', function(d){
                        switchmode(!block)
                        block = !block
                    });

                    group.append("rect")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("width", xscale.bandwidth()+12)
                    .attr("height", yscale.bandwidth());
                    group.append("text")
                        .text("Switch")
                        .attr("x", 0)
                        .attr("y", yscale.bandwidth()-5)
                        .attr("fill", "white")
                        .style("font-size", "23")
                    ;


        });


    </script>
</body>
</html>